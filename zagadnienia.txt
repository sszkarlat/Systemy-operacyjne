zadanie 0.
#!/bin/bash

if [ "$#" -ne 2 ];then
        echo "Sposob uzycia: $0 <zakres X> <zakres Y>"
        exit 1
fi

x=$1
y=$2
pytania=0
poprawne=0
bledne=0

echo "Podanie 0 lub wartosci ujemnej konczy dzialanie programu."

while true;do
        liczba1=$(( (RANDOM % x) + 1))
        liczba2=$(( (RANDOM % y) + 1))

        echo "Podaj wynik $liczba1 * $liczba2."

        read -p "Podaj odpowiedz: " odp

        poprawnaOdp=$((liczba1*liczba2))

        if [ "$odp" -le 0 ];then
                echo -e "\nStatystyki:"
                echo "Poprawne odp: $poprawne"
                echo "Bledne odp: $bledne"
                echo "Wszystkie pytania: $pytania"
                break
        else
                if [ "$odp" -eq "$poprawnaOdp" ];then
                        ((poprawne++))
                        echo "Poprawna odp"
                else
                        ((bledne++))
                        echo "Bledna odp"
                fi
                ((pytania++))
        fi
done

zadanie 0.5
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Sposob uzycia: %s <zakres X> <zakres Y>\n", argv[0]);
        return 1;
    }

    int x = atoi(argv[1]);
    int y = atoi(argv[2]);
    int pytania = 0;
    int poprawne = 0;
    int bledne = 0;

    printf("Podanie 0 lub wartosci ujemnej konczy dzialanie programu.\n");

    srand(time(NULL));

    while (1) {
        int liczba1 = (rand() % x) + 1;
        int liczba2 = (rand() % y) + 1;

        printf("Podaj wynik %d * %d: ", liczba1, liczba2);

        int odp;
        scanf("%d", &odp);

        int poprawnaOdp = liczba1 * liczba2;

        if (odp <= 0) {
            printf("\nStatystyki:\n");
            printf("Poprawne odp: %d\n", poprawne);
            printf("Bledne odp: %d\n", bledne);
            printf("Wszystkie pytania: %d\n", pytania);
            break;
        } else {
            if (odp == poprawnaOdp) {
                poprawne++;
                printf("Poprawna odp\n");
            } else {
                bledne++;
                printf("Bledna odp\n");
            }
            pytania++;
        }
    }

    return 0;
}


zadanie 1.
Polecenie wyświetla uprawnienia do pliku, w bierzącym katalogu tj. Desktop. Następnie wybiera tylko pliki zwykłe (plik zwykły, ma na początku "-"), następnie tylko pierwsza kolumna, następnie grupujemy (sort bez opcji), kolejno liczymy te linie, następnie sortujemy malejąco.
ls -la | grep "^-" | awk '{print $1}' | sort | uniq -c | sort -nr
Wynik polecenia:
     12 -rw-r--r--
      5 -rwxr-xr-x
      1 -rwxrw-rw-
      1 -r--------

zadanie 2.
Zmiana uprawnien wszystkim plikom w podanym katalogu, jedyne uprawnienia to odczyt (r)
chmod +r pliki/*
chmod 700 pliki/*
----------
Znajdź w plikach najdłuższe słowo składające się z liter [a-zA-Z].
ls | grep -o -E '\b[a-zA-Z]+\b' | awk '{print $1, length}' | sort -k 2 -nr | head -1
wyrażenia regularne
WAŻNE: najlepiej dawać pojedyncze nawiasy.

zadanie 3.
Zadanie napisane w bash
Mediana podanych liczb całkowitych
#!/bin/bash

mediana() {
        local numbers=($(echo "$1" | tr ' ' '\n' | sort -n))
        local len=${#numbers[@]}
        local middle=$((len/2))

        echo "${numbers[middle]}"
}


if [ "$#" -eq 0 ];then
        echo "Uzycie $0 <lista_liczb>"
        exit
elif [ $(( $# % 2)) -eq 0 ];then
        echo "Liczba liczb musi byc nieparzysta"
        exit
else
        data="$@"
        echo $(mediana "$data")
fi

zadanie 4.
Polecenia:
ps aux - wyświetla informacje o wszystkich procesach
pgrep -f "sleep 2000" - polecenie pomocne jest jeżeli chcemy wyświetlić PID procesu, który ma dw człony np. komenda i parametr
pkill -f "sleep 3000" - służy do killowania procesu
pidwait - polecenie czeka 
We wszystkich tych przypadkach można wprowadzić nazwę komendy, która utworzyła dany proces
----------
Polecenie trochę bardziej na około
kill -9 `ps aux | grep "sleep 2000" | head -1 | awk '{print$2}'`

