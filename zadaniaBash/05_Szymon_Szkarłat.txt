Szymon Szkarłat
Laboratorium 5.
-------------------------------------------------
-------------------------------------------------


Zadania:
Zadanie 1.
zmienna noclobber nie jest zdefiniowana. Dzięki tej funkcji plik nie jest nadpisywany, wtedy należy użyć >|
Polecenie: set -o noclobber
-------------------------------------------------

Zadanie 2.
W pliku o nazwie "wyjscia.c" zapisujemy kod źródłowy programu, który jest podany w poleceniu.
Następnie kompilujemy program poleceniem: gcc -o wyjscia wyjscia.c
Kolejno za pomocą polecenia: ./wyjscia 1> std.txt 2> err.txt sprawiamy, że komunikaty wypisywane przez nasz program zostaną zapisane odpowiednio do plików std.txt oraz err.txt, a potem za pomocą polecenia: ./wyjscia &> razem.txt obaz komunikaty pojawią się w jednym pliku o nazwie razem.txt.
-------------------------------------------------

Zadanie 3.
Polecenie, które sprawdza, ile ostatnio wydanych komend pamiętanych jest w shellu: set | wc -l.
Wynik: 61
Wywołujemy komende set, aby sprawdzić jakie komendy zostały ostatnio wydane 
-------------------------------------------------

Zadanie 4.
Polecenie: set | grep HISTFILE 
Wynik: HISTFILE=/home/ietgrp/sszkarla/.bash_history
Komenda: history - pokaże historię poleceń
Polecenie: !! - wykona ostatnie polecenie w historii
Polecenie: !s - wykona ostatnie polecenie rozpoczynające się na litere "g" Wynik: gcc -o signal ~/c3/signal.c
Polecenie: !536 wykona polecenie znajdujące się pod numerem 536 w historii, czyli w moim przypadku cd~
-------------------------------------------------

Zadanie 5.
Najpierw podajemy komende bash, kolejno zmienną TMOUT ustawiamy np. na 10 (TMOUT=10). Oznacza to, zę po 10 sekundach (bo w takim formacie podawany jest czas) bezczynności nastąpi wylogowanie z systemu. 
-------------------------------------------------

Zadanie 6.
Uruchamiamy powłokę bash poleceniem: bash.
Następnie ustawiamy zmienną środowiskową IGNOREEOF na 4 (IGNOREEOF=4), oznacza to, że dopiero za 5 razem, gdy naciśniemy ctrl-d zostaniemy odłączeni od systemu
-------------------------------------------------

Zadanie 7.
Polecenie: PATH=$PATH:$PWD
Wynik: echo $PATH
:/home/ietgrp/sszkarla
-------------------------------------------------

Zadanie 8.
Polecenie 1: PS1='\u@\h \A \w \$ '
Wynik 1: sszkarla@student 21:34 / $
Polecenie 2: PS2='!'
-------------------------------------------------

Zadanie 9.
Polecenie "alias" sprawdza już zdefiniowane aliasy: alias
Dodajemy własny alias o nazwie ll i postaci: alias ll='ls -al --color=always | less'.
Musimy poprawić ten alias o nazwie ll: alias ll='ls -al --color=always | less -R'.
-------------------------------------------------

Zadanie 10.
Polecenie 1: echo export PS1='\u@\h \A \w \$' >> $HOME/.profile
Wynik 1: doda linijkę do pliku
Polecenie 2: echo alias ll='ls -al --color=always | less -R' >> /etc/bashrc
Polecenie 3:echo export IGNOREEOF=4 >> $HOME/.bashrc
Polecenie 4:echo export TMOUT=10 >> $HOME/.bashrc
-------------------------------------------------
-------------------------------------------------


Zadania sprawdzające:
Zadanie 1.
Aby „doświadczalnie” sprawdzić, jaki jest znak kontynucji (PS2) wystarczy otworzyć nawias i wcisnąć Enter. Znak na początku nowej lini to znak kontynuacji.
-------------------------------------------------

Zadanie 2.
Polecnie: echo $(($(set | awk '/^[[:upper:]]/ {print}' | wc -l) - $(env | awk '/^[[:upper:]]/ {print}' | wc -l)))
Wynik: 30
-------------------------------------------------

Zadanie 3.
Komenda tmux uruchamia nowy interpreter interaktywny.
-------------------------------------------------
-------------------------------------------------